/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package homework04

import java.nio.ByteBuffer


data class Location<T : Any>(val input: T, val offset: Int = 0)

sealed class Result<A : Any>

data class Success<A : Any>(val value: A, val consumed: Int) : Result<A>() {
    fun <T : Any, U : Any> mergeRight(other: Success<T>, f: (A, T) -> U): Success<U> =
        Success(f(value, other.value), consumed + other.consumed)

    override fun toString(): String {
        return value.toString()
    }
}

data class ParseError<T : Any>(val stack: List<Pair<Location<T>, String>>)

data class Failure<V : Any, T : Any>(val get: ParseError<V>) : Result<T>() {
    fun <T : Any> transform(): Failure<V, T> {
        return Failure(get)
    }

    override fun toString(): String {
        return get.stack.joinToString(separator = "\n", prefix = "Failure while parsing: ")
        { (loc, str) -> "$str at pos ${loc.offset}" }
    }
}


infix fun <T> T.cons(la: List<T>): List<T> = listOf(this) + la

fun <V : Any> ParseError<V>.push(loc: Location<V>, msg: String): ParseError<V> =
    this.copy(stack = (loc to msg) cons this.stack)

fun <V : Any, A : Any> BaseParser<V, A>.addErrorMessage(msg: String) = scope(msg, this)

fun <V : Any, A : Any> scope(msg: String, pa: BaseParser<V, A>): BaseParser<V, A> =
    { state -> pa(state).mapError { pe: ParseError<V> -> pe.push(state, msg) } }

fun <V : Any, A : Any> Result<A>.mapError(f: (ParseError<V>) -> ParseError<V>): Result<A> =
    when (this) {
        is Success -> this
        is Failure<*, *> -> Failure(f(this.get as ParseError<V>))
    }

fun <V : Any> Location<V>.toError(msg: String) = ParseError(listOf(this to msg))

fun <T : Any> Location<T>.advanceBy(n: Int): Location<T> =
    this.copy(offset = this.offset + n)


typealias BaseParser<V, A> = (Location<V>) -> Result<A>

typealias ByteParser<A> = BaseParser<ByteBuffer, A>

typealias StringParser<A> = BaseParser<String, A>


interface ByteParsers {

    fun eof(): ByteParser<String> = { loc ->
        if (loc.offset == loc.input.capacity()) {
            Success("", 0)
        } else Failure(loc.toError("Expected end of input, got ${loc.input[loc.offset]}"))
    }


    fun skipBytes(amount: Int): ByteParser<String> = { loc ->
        val newPos = loc.input.position() + amount
        if (newPos >= loc.input.limit()) {
            Failure(loc.toError("Unexpected end of input"))
        } else {
            loc.input.position(newPos)
            Success("", amount)
        }
    }

    fun array(amount: Int) = DefaultParsers().manyN(bytes(amount))

    fun bytes_range(amount: Int, values: Set<UInt>) = { loc: Location<ByteBuffer> ->
        val res = when (amount) {
            1 -> loc.input.get().toUInt()
            2 -> loc.input.short.toUInt()
            4 -> loc.input.int.toUInt()
            else -> throw UnsupportedOperationException("Trying to read unsupported amount of bytes")
        }
        if (res in values) Success(res, amount) else
            Failure(loc.toError("Expected: value in $values, got $res"))
    }

    fun bytes_range(amount: Int, lb: UInt, ub: UInt) = { loc: Location<ByteBuffer> ->
        val res = when (amount) {
            1 -> loc.input.get().toUInt()
            2 -> loc.input.short.toUInt()
            4 -> loc.input.int.toUInt()
            else -> throw UnsupportedOperationException("Trying to read unsupported amount of bytes")
        }
        if (res in lb..ub) Success(res, amount) else
            Failure(loc.toError("Expected: value between $lb and $ub, got $res"))
    }

    fun bytes(amount: Int) = bytes_range(amount, UInt.MIN_VALUE, UInt.MAX_VALUE)

    fun bytes(amount: Int, value: UInt) = bytes_range(amount, value, value)

}


interface CharParsers {
    fun charParser(accept: Char, ret: String): StringParser<String> = { loc ->
        when (val c = loc.input[loc.offset]) {
            accept -> Success(ret, 1)
            else -> Failure(loc.toError("Expected: $accept, got $c "))
        }
    }

    fun expectChar(c: Char) = charParser(c, "$c")

    fun readChar(): StringParser<Char> = { loc ->
        if (loc.offset >= loc.input.length) {
            Failure(loc.toError("Index out of bounds for reading: ${loc.offset} out of ${loc.input.length}"))
        } else Success(loc.input[loc.offset], 1)
    }
}


interface Combinators {

    fun <V : Any, T : Any, U : Any> DefaultParsers.transform(parser: BaseParser<V, T>, f: (T) -> U) =
        flatMap(parser) { constant(f(it)) }

    fun <T : Any, V : Any> constant(res: Result<T>): BaseParser<V, T> = { input ->
        res
    }

    fun <T : Any, V : Any> fail(msg: String): BaseParser<V, T> = { input ->
        Failure(input.toError(msg))
    }

    fun <V : Any, T : Any> many(parser: BaseParser<V, T>): BaseParser<V, List<T>> = { input ->
        when (val res = parser(input)) {
            is Success -> {
                val rest = many(parser)(input.advanceBy(res.consumed))
                if (rest is Success) {
                    res.mergeRight(rest) { a, b -> a cons b }
                } else res.mergeRight(Success(listOf<T>(), 0)) { a, b -> a cons b }

            }
            else -> {
                (res as Failure<*, *>).transform()
            }
        }
    }

    fun <T : Any, V : Any> manyN(parser: BaseParser<V, T>, dec: UInt = 0u) = { count: UInt ->
        multiseq(*Array((count - dec).toInt()) { parser })
    }

    fun <V : Any, T : Any> constant(res: T): BaseParser<V, T> = constant(Success(res, 0))

    fun <V : Any, T : Any> or(vararg parsers: BaseParser<V, T>): BaseParser<V, T> = { input ->
        var res = parsers.first()(input)
        for (cur in parsers.drop(1)) {
            if (res is Failure<*, *>) res = cur(input)
            else break
        }
        res
    }

    fun <T, U> mergeToList() = { a: T, b: U -> if (a is List<*>) a + b else listOf(a, b) }

    fun <V : Any> nothing(): BaseParser<V, List<*>> = { Success(arrayListOf<Any>(), 0) }

    fun <V : Any> multiseq(vararg parsers: BaseParser<V, *>): BaseParser<V, List<*>> = { state ->
        parsers.fold(nothing<V>()(state)) { acc, cur ->
            when (acc) {
                is Success -> when (val parsed = cur(state.advanceBy(acc.consumed))) {
                    is Failure<*, *> -> parsed.transform()
                    is Success -> acc.mergeRight(parsed, mergeToList())
                }
                is Failure<*, *> -> acc
            }
        }
    }

    fun <V : Any, A : Any, B : Any> flatMap(pa: BaseParser<V, A>, f: (A) -> BaseParser<V, B>) =
        flatMap(pa, f) { _, b -> b }

    fun <V : Any, A : Any, B : Any, C : Any> flatMap(
        pa: BaseParser<V, A>,
        f: (A) -> BaseParser<V, B>,
        merge: (A, B) -> C
    ): BaseParser<V, C> =
        { state ->
            when (val firstValue = pa(state)) {
                is Success -> {

                    when (val secondValue = f(firstValue.value)(state.advanceBy(firstValue.consumed))) {
                        is Failure<*, *> -> {
                            secondValue.transform()
                        }
                        is Success -> {
                            firstValue.mergeRight(secondValue) { a, b -> merge(a, b) }
                        }
                    }
                }

                is Failure<*, *> -> firstValue.transform()
            }
        }

}


// ()
open class DefaultParsers : Parsers, CharParsers, Combinators {
    override fun <V : Any, A : Any> run(p: BaseParser<V, A>, input: V): Result<A> = p(Location(input))
}


interface Parsers {
    fun <V : Any, A : Any> run(p: BaseParser<V, A>, input: V): Result<A>
}

interface StringParsers {
    fun manyString(parser: StringParser<String>) = with(DefaultParsers()) {
        transform(many(parser)) {
            it.joinToString(separator = "") { it }
        }
    }


    fun eof(): StringParser<String> = { loc ->
        if (loc.offset == loc.input.length) {
            Success("", 0)
        } else Failure(loc.toError("Expected end of input, got ${loc.input[loc.offset]}"))
    }

    fun expectString(str: String): StringParser<String> = with(DefaultParsers()) {
        transform(multiseq(*str.map { expectChar(it) }.toTypedArray()))
        { c -> c.joinToString(separator = "") { it.toString() } }
    }

    fun combineStrings(vararg parsers: StringParser<String>): StringParser<String> = { input ->
        val res = StringBuilder()
        val list = DefaultParsers().multiseq(*parsers)(input)
        if (list is Failure<*, *>) {
            list.transform()
        } else {
            for (str in (list as Success).value) {
                res.append(str.toString())
            }
            Success(res.toString(), list.consumed)
        }

    }
}











