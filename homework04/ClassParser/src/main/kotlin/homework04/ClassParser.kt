/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package homework04

import java.io.File
import java.io.FileNotFoundException
import java.nio.BufferUnderflowException
import java.nio.ByteBuffer
import kotlin.collections.ArrayList


class ClassParser : ByteParsers, DefaultParsers() {
    companion object {
        val JAVA_MAGIC_NUMBER = 3405691582U

        val CONSTANT_POOL_TAGS = setOf(1u, 3u, 4u, 5u, 6u, 7u, 8u, 9u, 10u, 11u, 12u, 15u, 16u, 17u, 18u, 19u, 20u)

        val CLASS_ACCESS_TAGS = mapOf(
            Pair(0x0001u, "public"),
            Pair(0x0010u, "final"),
            Pair(0x0020u, "super"),
            Pair(0x0200u, "interface"),
            Pair(0x0400u, "abstract"),
            Pair(0x1000u, "synthetic"),
            Pair(0x2000u, "annotation "),
            Pair(0x4000u, "enum"),
            Pair(0x8000u, "module"),
        )

        val FIELD_ACCESS_TAGS = mapOf(
            Pair(0x0001u, "public"),
            Pair(0x0002u, "private"),
            Pair(0x0004u, "protected"),
            Pair(0x0008u, "static"),
            Pair(0x0010u, "final"),
            Pair(0x0040u, "volatile"),
            Pair(0x0080u, "transient "),
            Pair(0x1000u, "synthetic"),
            Pair(0x4000u, "enum "),
        )

        val METHOD_ACCESS_TAGS = mapOf(
            Pair(0x0001u, "public"),
            Pair(0x0002u, "private"),
            Pair(0x0004u, "protected"),
            Pair(0x0008u, "static"),
            Pair(0x0010u, "final"),
            Pair(0x0020u, "synchronized"),
            Pair(0x0040u, "bridge"),
            Pair(0x0080u, "varargs"),
            Pair(0x0100u, "native"),
            Pair(0x0400u, "abstract"),
            Pair(0x0800u, "strictfp"),
            Pair(0x1000u, "synthetic"),
        )
    }


    fun classParser(): ByteParser<String> = { input ->
        val magicParser = bytes(4, JAVA_MAGIC_NUMBER).addErrorMessage("Invalid magic")
        val minorParser = bytes(2)
        val majorParser = { small: UInt ->
            if (small.toUShort() == UShort.MIN_VALUE || small.toUShort() == UShort.MIN_VALUE)
                bytes_range(2, 45u, 63u)
            else bytes_range(2, 45u, 55u)
        }

        val versionParser =
            flatMap(minorParser, { majorParser(it) }, { a, b -> "Version $b.$a" }).addErrorMessage("Invalid version")

        val constantPoolParser =
            flatMap(bytes(2), manyN(cpEntry(), 1u)).addErrorMessage("Error while parsing CP_table")

        val flagsParser = transform(bytes_range(2, 1u, 0x1000u)) {
            constructMods(
                it,
                CLASS_ACCESS_TAGS
            )
        }.addErrorMessage("Error while parsing class flags")

        val nameParser = multiseq(bytes(2), bytes(2)).addErrorMessage("Error while parsing class and superclass names")

        val interfaceParser = flatMap(bytes(2), array(2)).addErrorMessage("Error while parsing interfaces")

        val fieldParser = flatMap(bytes(2), manyN(fieldEntry())).addErrorMessage("Error while parsing fields")

        val methodParser = flatMap(bytes(2), manyN(methodEntry())).addErrorMessage("Error while parsing methods")

        val classAttributesParser =
            flatMap(bytes(2), manyN(entryName())).addErrorMessage("Error while parsing class attributes")

        val classParser = multiseq(
            magicParser,
            versionParser, constantPoolParser, flagsParser,
            nameParser, interfaceParser,
            fieldParser,
            methodParser,
            classAttributesParser, eof()
        )


        val allParser = transform(classParser) { list ->
            if (list.size < 9) {
                return@transform "Incorrect .class file"
            }

            val sep = System.lineSeparator()
            val res = StringBuilder(list[1].toString()).append(sep)
            with(res) {
                append("Class: ").append(
                    (list[3] as List<*>).joinToString(
                        separator = " ",
                        postfix = " "
                    ) { it.toString() })

                val table = (list[2] as List<*>)
                fun getString(index: UInt): String {
                    val utf8Info = table[index.toInt()] as List<*>
                    if (utf8Info[0] != 1) return "Invalid CP_table entry: not a utf8_info"
                    return (table[index.toInt()] as List<*>)[1].toString()
                }

                fun getConstantFormat(index: UInt): String {
                    val constantClassInfo = (table[index.toInt()] as List<*>)
                    if (constantClassInfo[0] != 7) return "Invalid CP_table entry: not a constant_info"
                    val actualIndex = (constantClassInfo[1] as UInt).dec()
                    return getString(actualIndex)
                }

                fun getFormat(isMethod: Boolean) = { method_info: List<*> ->

                    val result = StringBuilder((method_info.first() as List<*>)
                        .joinToString(separator = " ", postfix = " ") { it.toString() })
                    val name = getString((method_info[1] as UInt).dec())
                    val parser = if (isMethod) methodSignatureParser(name) else fieldSignatureParser()
                    val run = run(parser, getString((method_info[2] as UInt).dec()))
                    val descriptor = if (run is Success) run.value else ""

                    val attributes = (method_info[3] as List<*>).joinToString { getString((it as UInt).dec()) }
                    result.append(descriptor).append(if (!isMethod) "$name$sep" else sep)
                    if (attributes.isNotEmpty()) result.append("Attributes: $attributes")
                    result.toString()
                }


                val (classIndex, superIndex) = (list[4] as List<*>).map { (it as UInt).dec() }

                append(getConstantFormat(classIndex)).append(sep)

                append("Superclass: ").append(getConstantFormat(superIndex)).append(sep)
                append("Interfaces: ").append((list[5] as List<*>).joinToString { getConstantFormat((it as UInt).dec()) })

                append(sep).append("Fields:").append(sep)
                (list[6] as List<*>).forEach { append(getFormat(false)(it as List<*>)).append(sep) }

                append("Methods: ").append(sep)
                (list[7] as List<*>).forEach { append(getFormat(true)(it as List<*>)).append(sep) }

                append("Class attributes: ")
                append((list[8] as List<*>).joinToString { getString((it as UInt).dec()) }).append(sep)
            }
            res.toString()
        }

        allParser(input)
    }

    private fun abstractEntry(tags: Map<UInt, String>) = multiseq(
        transform(bytes_range(2, 1u, 0x4000u)) { constructMods(it, tags) },
        bytes(2), bytes(2), flatMap(bytes(2), manyN(entryName()))
    )


    private fun entryName(): ByteParser<Any> {
        val res = multiseq(bytes(2), flatMap(bytes(4)) { skipBytes(it.toInt()) })
        return transform(res) { it.first() ?: listOf<Any>() }
    }

    private fun fieldEntry() = abstractEntry(FIELD_ACCESS_TAGS).addErrorMessage("Invalid field entry")

    private fun methodEntry() = abstractEntry(METHOD_ACCESS_TAGS).addErrorMessage("Invalid method entry")

    private fun cpEntry() = flatMap(bytes_range(1, CONSTANT_POOL_TAGS)) { tag ->
        when (val tg = tag.toInt()) {
            7, 8, 16, 19, 20 -> multiseq(constant(tg), bytes(2))
            9, 10, 11, 12, 17, 18 -> multiseq(constant(tg), bytes(2), bytes(2))
            3, 4 -> multiseq(constant(tg), bytes(4))
            5, 6 -> multiseq(constant(tg), bytes(4), bytes(4))
            15 -> multiseq(constant(tg), bytes(1), bytes(2))

            else -> multiseq(constant(tg),
                transform(flatMap(bytes(2), array(1)))
                { list -> list.joinToString(separator = "") { Char((it as UInt).toInt()).toString() } }
            )
        }
    }.addErrorMessage("Invalid constant pool entry")

    private fun constructMods(num: UInt, tags: Map<UInt, String>): ArrayList<String> {
        val res = arrayListOf<String>()
        for (value in tags.keys) {
            if ((num and value) != 0u) {
                res.add(tags[value] ?: "")
            }
        }
        return res
    }

    private fun nameParser(): StringParser<String> = { loc ->
        with(loc.input) {
            when (val c = this[loc.offset]) {
                'L' -> {
                    val ind = indexOf(';', loc.offset)
                    if (ind == -1) {
                        Failure<String, String>(loc.toError("Incorrect link name: ; not found"))
                    }
                    val str = substring(loc.offset + 1, ind)
                    Success(str, str.length + 2)
                }
                else -> Failure(loc.toError("Expected: L, got $c"))
            }
        }
    }

    private fun Location<String>.readWhile(predicate: (Char) -> Boolean): Int {
        var res = offset
        while (res < input.length && predicate(input[res])) {
            res++
        }
        return res
    }

    private fun dimensionParser(): StringParser<String> = { loc ->
        when (val c = loc.input[loc.offset]) {
            '[' -> {
                val ind = loc.readWhile { it == '[' }
                val str = loc.input.substring(loc.offset, ind)
                val rest = scope(
                    "Expected field type after [, got: ", fieldSignatureParser()
                )(loc.advanceBy(ind - loc.offset))
                if (rest is Success) {
                    val sb = StringBuilder(rest.value).append("[]".repeat(str.length))
                    Success(sb.toString(), str.length + rest.consumed)
                } else rest
            }
            else -> Failure(loc.toError("Expected: L, got $c "))
        }
    }


    private fun fieldSignatureParser(): StringParser<String> = ClassParser().or(
        charParser('B', "byte"), charParser('C', "char"),
        charParser('D', "double"), charParser('F', "float"),
        charParser('I', "int"), charParser('J', "long"),
        nameParser(), charParser('S', "short"), charParser('Z', "boolean"),
        dimensionParser()
    ).addErrorMessage("Invalid field signature")


    private fun methodSignatureParser(name: String): StringParser<String> = { input: Location<String> ->
        val res = multiseq(
            charParser('(', "("), or(many(fieldSignatureParser()), constant(listOf())), charParser(')', ")"),
            or(fieldSignatureParser(), charParser('V', "void"))
        )(input)
        if (res is Success) {
            val list = res.value
            val sb = StringBuilder(list[3].toString()).append(" ").append(name)
            sb.append("(").append((list[1] as List<*>).joinToString { it.toString() }).append(")")
            Success(sb.toString(), res.consumed)
        } else (res as Failure<*, *>).transform()

    }.addErrorMessage("Invalid method signature")

}


fun main(args: Array<String>) {
    if (args.isEmpty()) {
        println("File to analyze was not specified")
        return
    }
    try {
        with(ClassParser()) {
            println(run(classParser(), ByteBuffer.wrap(File(args.first()).readBytes())))
        }

    } catch (e: FileNotFoundException) {
        println(e.message)
        return
    } catch (e: BufferUnderflowException) {
        println("Invalid .class file")
        return
    }

}







