/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package homework03


import com.fasterxml.jackson.annotation.*
import com.fasterxml.jackson.annotation.JsonSubTypes.Type
import com.fasterxml.jackson.annotation.JsonTypeInfo.Id
import com.fasterxml.jackson.core.JsonParser
import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.databind.*
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.engine.cio.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.serialization.jackson.*
import io.ktor.utils.io.errors.*
import kotlinx.coroutines.*
import java.io.FileOutputStream
import kotlin.reflect.KClass
import kotlin.reflect.full.memberProperties


fun <T: Any> csvSerialize(data: Iterable<T>, klass: KClass<T>) = buildString { serializeObject(data, klass) }

private fun <T: Any> StringBuilder.serializeObject(data: Iterable<T>, klass: KClass<T>) {
    serializeHeader(klass)
    append("\n")

    if (data.any {
            it.javaClass.kotlin != klass
        }) throw IllegalArgumentException("not all types match")

    data.forEach {
        serializeObject(it)
        append("\n")
    }
}

private fun StringBuilder.serializeNumber(value: Number) = apply {
    append(value)
}

private fun StringBuilder.serializeValue(value: Any) = apply {
    val kClass = value.javaClass.kotlin
    when (kClass) {
        String::class -> {
            serializeString(value as String)
        }
        Integer::class, Short::class, Long::class, Byte::class, Float::class, Double::class -> {
            serializeNumber(value as Number)
        }
    }
}

private fun StringBuilder.serializeString(value: String) = apply {
    append('"')
    append(value)
    append('"')
}

private fun <T: Any> StringBuilder.serializeHeader(klass: KClass<T>) = apply {
    append("")
    val properties = klass.memberProperties

    when (klass) {
        String::class -> {
            serializeString("value")
        }
        else -> {
            properties.joinTo(this, ",") { p ->
                serializeString(p.name)
                ""
            }
        }
    }
}

private fun StringBuilder.serializeObject(value: Any) {
    val kClass = value.javaClass.kotlin
    val properties = kClass.memberProperties

    when (kClass) {
        String::class -> {
            serializeString(value as String)
        }
        else -> {
            properties.joinTo(this, ",") { p ->
                serializeValue(p.get(value) ?: "null")
                ""
            }
        }
    }
}




data class TopicSnapshot(val info: TopicInfo, val posts: List<Post>) {
    val id: Int = hashCode()
    val created: Long = System.currentTimeMillis()
}


@JsonIgnoreProperties(ignoreUnknown = true)
data class TopicInfo(val active_user_count: Int, val subscribers: Int,
                     val public_description: String, val created_utc: Long,
                     val title: String, val id: String): RedditSnapshot

@JsonIgnoreProperties(ignoreUnknown = true)
data class Post(val selftext: String, val subreddit_id: String,
                val author: String, val ups: Int, val downs: Int,
                val created_utc: Long, val selftext_html: String?,
                val title: String, val num_comments: Int, val id: String) : RedditSnapshot

data class CommentsSnapshot(val comments: List<Comment>) {
    val id: Int = hashCode()
    val created: Long = System.currentTimeMillis()
}

class CommentsDeserializer : JsonDeserializer<Listing?>() {
    @Throws(IOException::class, JsonProcessingException::class)
    override fun deserialize(jp: JsonParser, ctxt: DeserializationContext?): Listing? {
        val rootNode: JsonNode = jp.readValueAsTree()
        val mapper = jacksonObjectMapper()
        mapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true)

        if (rootNode.get("kind") == null) {
            return null
        }
        return Listing(mapper.readValue(rootNode.get("data").toString(), AfterBefore::class.java))
    }
}

@JsonIgnoreProperties(ignoreUnknown = true)
data class Comment(val created_utc: Long, val ups: Int, val downs: Int, val depth: Int, val body: String,
                    val author: String, val id: String, val parent_id: String,
                   val subreddit_id: String,
                   @JsonDeserialize(using = CommentsDeserializer::class) val replies: Listing?) : RedditSnapshot

@JsonIgnoreProperties(ignoreUnknown = true)
data class MoreComments(val created_utc: Int, val ups: Int, val downs: Int, val depth: Int,
                        val id: String, val parent_id: String, val children: List<String>) : RedditSnapshot

@JsonTypeInfo(use = Id.DEDUCTION)
@JsonSubTypes(Type(value = TopicInfo::class), Type(value = Comment::class), Type(value = Post::class),
                Type(value = MoreComments::class))

interface RedditSnapshot

@JsonIgnoreProperties(ignoreUnknown = true)
data class Kind(val data: RedditSnapshot)

@JsonIgnoreProperties(ignoreUnknown = true)
data class AfterBefore(val children: List<Kind>)

@JsonIgnoreProperties(ignoreUnknown = true)
data class Listing(val data: AfterBefore) {
    fun getList(): List<Kind> = data.children
}


class RedditClient {
    val greeting: String
        get() {
            return "Hello World!"
        }

    suspend fun getTopic(name: String): TopicSnapshot = coroutineScope {
        HttpClient(CIO) {
            install(ContentNegotiation) { jackson() }
        }.use { client ->
            try {
                val info: Deferred<Kind> = async { client.get("https://www.reddit.com/r/$name/about.json").body() }
                val posts: Deferred<Listing> = async { client.get("https://www.reddit.com/r/$name/.json").body() }
                TopicSnapshot(info.await().data as TopicInfo, posts.await().getList().map { it.data as Post })
            } catch (e: Exception) {
                println("Didn't manage to load Reddit :/")
                throw e
            }
        }
    }

    private fun linearizeComments(comment: Comment): List<Comment> {
        if (comment.replies == null) {
            return listOf(comment)
        }
        val replies: List<List<Comment>> = comment.replies.getList().filter { it.data is Comment }.map { it.data as Comment }.map {
            linearizeComments(it)
        }
        return replies.flatten().plus(comment)
    }


    suspend fun getComments(id: String): CommentsSnapshot {
        return HttpClient(CIO) { install(ContentNegotiation) { jackson() }
        }.use { client ->
            try {
                val post: List<Listing> = client.get("https://www.reddit.com/comments/$id/.json").body()
                CommentsSnapshot(post[1].getList().filter { it.data is Comment }.map { it.data as Comment }.map {
                    linearizeComments(it) }.flatten())
            } catch (e: Exception) {
                println("Didn't manage to load Reddit :/")
                throw e
            }
        }
    }

    private suspend fun writeTopic(topicSnapshot: TopicSnapshot) {
        withContext(Dispatchers.IO) {
            FileOutputStream("subjects.csv", true).bufferedWriter()
        }.use { out ->
            out.append("\"id\",\"created\"\n")
            out.append(topicSnapshot.id.toString() + "," + topicSnapshot.created.toString() + "\n")
            out.append(csvSerialize(listOf(topicSnapshot.info), TopicInfo::class))
            out.append(csvSerialize(topicSnapshot.posts, Post::class))
        }
    }

    private suspend fun writeComments(commentsSnapshot: CommentsSnapshot) {
        withContext(Dispatchers.IO) {
            FileOutputStream("comments.csv", true).bufferedWriter()
        }.use { out ->
            out.append("\"id\",\"created\"\n")
            out.append(commentsSnapshot.id.toString() + "," + commentsSnapshot.created.toString() + "\n")
            out.append(csvSerialize(commentsSnapshot.comments, Comment::class))
        }
    }

    suspend fun writeRedditSnapshot(subreddit: String) {
        coroutineScope {
            val topic = getTopic(subreddit)

            launch { writeTopic(topic) }
            launch {
                topic.posts.forEach {
                    if (it.num_comments != 0) {
                        val commentsSnapshot = getComments(it.id)
                        writeComments(commentsSnapshot)
                    }
                }
            }
        }
    }
}

fun main(args: Array<String>) {
    runBlocking {
        val app = RedditClient()
        args.forEach {
            app.writeRedditSnapshot(it)
        }
    }
}
